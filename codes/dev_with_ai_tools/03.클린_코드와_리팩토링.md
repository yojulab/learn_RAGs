# 클린 코드와 리팩토링:

개발을 하다 보면 **코드 작성** 자체보다 **코드 읽기**에 더 많은 시간이 들어갑니다. 여러 사람이 함께 프로젝트를 진행하거나, 시간이 지나 본인이 작성한 코드를 다시 볼 때 **깨끗하고 이해하기 쉬운 코드(클린 코드)**의 가치가 드러납니다. 본 강의에서는 파이썬을 기반으로 클린 코드의 개념과 중요성을 살펴보고, 주요 원칙들을 설명합니다. 또한 간단한 **나쁜 코드 vs 좋은 코드 예시**를 비교해보며, GitHub Copilot을 활용해 코드를 개선(리팩토링)하는 실습을 단계별로 진행해 보겠습니다.

## 클린 코드란 무엇이며 왜 중요한가?

**클린 코드**(Clean Code)란 이해하기 쉽고 유지보수가 용이하도록 작성된 깨끗한 코드를 뜻합니다. 한마디로 **가독성이 높고 불필요한 복잡성이 없는 코드**입니다. 클린 코드는 **소프트웨어의 품질**을 높여주며, 결함을 최소화하고 재사용성을 높이는 효과가 있습니다. 클린 코드의 가장 큰 가치는 협업과 장기 유지보수에서 나타납니다. 팀원 누구나 코드를 읽고 바로 이해할 수 있다면 개발 속도가 빨라지고, 버그를 찾거나 새로운 기능을 추가하기도 쉬워집니다. 반대로 **지저분한 코드**는 작성자 본인 외에는 이해하기 어려워 유지보수 비용을 크게 높이고, 팀 생산성을 떨어뜨리게 됩니다. 따라서 **개발자라면 클린 코드를 지향**해야 하며, 이는 다른 개발자와 효율적으로 소통하고 협업하는 기본 예의이기도 합니다.

## 클린 코드의 핵심 원칙

클린 코드를 구현하기 위해 널리 알려진 몇 가지 **핵심 원칙**이 있습니다. 아래 원칙들을 따르면 코드의 가독성과 품질을 향상시킬 수 있습니다.

- **의미 있는 이름 사용**: 변수, 함수, 클래스의 이름을 봤을 때 역할이 명확해야 합니다. `a`, `b`처럼 모호한 이름 대신 `total_price`, `send_email()`처럼 **의도를 드러내는 이름**을 사용합니다. 이름만으로 코드의 동작을 유추할 수 있다면 주석이 최소화되고 코드 자체로 문서화가 됩니다.

- **함수는 하나의 일만 수행 (단일 책임)**: 하나의 함수나 메서드는 **하나의 책임**만 가지도록 설계합니다. 여러 가지 일을 한 함수에 몰아넣지 말고, 동작을 잘게 나누어 작은 함수 여러 개로 분리하세요. 예를 들어 데이터 검증과 계산 로직은 따로 함수로 나누는 식입니다. 이렇게 하면 각 함수가 짧고 명확해져서 이해하기 쉽고 재사용도 편리합니다.

- **중복 코드 제거 (DRY 원칙)**: *DRY(Do not Repeat Yourself)* 원칙처럼, 동일한 기능이나 로직을 여러 곳에서 반복하지 않습니다. 코드를 중복해 두면 한 부분만 수정하고 다른 부분을 빼먹기 쉽고, 유지보수할 곳이 많아져 버그 발생 확률이 높아집니다. 따라서 중복된 코드는 공통 함수나 모듈로 추출하여 한 곳에서만 수정하도록 합니다. 

- **들여쓰기 최소화**: 코드는 **너무 깊게 중첩되지 않도록** 작성해야 합니다. 들여쓰기 수준이 깊다는 것은 복잡한 로직이 한 함수에 얽혀 있음을 의미하므로, 조건문이나 반복문이 여러 겹이 되지 않게 리팩토링합니다. **각 블록은 가능한 한 한 가지 작업만 하도록 작성**하고, 경우에 따라서는 조건에 맞지 않으면 함수를 일찍 종료(return)하여 아래에 불필요한 중첩이 생기지 않게 하는 기법(가드 cláus 등)을 활용합니다. 실제로 클린 코드의 한 규칙으로 *"if, else, while, for문 등의 블록은 가능하면 한 줄만 사용하고 하나의 들여쓰기만 허용한다"*라는 말이 있습니다. 이는 극단적으로 함수를 잘게 쪼개라는 의미로, 결국 들여쓰기를 줄여 **코드 구조를 평평하게**(flat) 만들어 가독성을 높이려는 것입니다.

- **부작용 없는 함수**: 함수나 메서드는 가능한 한 **부작용**(side effect)이 없도록 작성합니다. 여기서 부작용이란 함수의 겉보기 동작 외에 숨겨진 상태 변화나 입출력을 말합니다. 예를 들어 전역 변수를 함수 안에서 수정하거나, 함수 내부에서 예상치 못한 파일 I/O나 네트워크 통신을 하는 것은 부작용입니다. 부작용이 많으면 함수의 동작이 복잡해지고 예측하기 어려워집니다. 따라서 **입력 값을 받아 결과만 반환**하고, 외부 상태를 변경하지 않는 순수 함수를 작성하려고 노력해야 합니다. 부작용을 줄이면 동일한 입력에 항상 같은 결과를 내는 함수를 만들 수 있고, 테스트도 수월해집니다.

이 밖에도 **KISS**(Keep It Simple, Simple!) 원칙처럼 코드 구조를 단순하게 유지하고 과도한 최적화나 복잡도를 지양하는 태도도 클린 코드에 포함됩니다. 핵심은 코드를 작성할 때 “**나 또는 동료가 나중에 이 코드를 봤을 때 이해하기 쉽게 하자**”라는 마음가짐으로 위 원칙들을 적용하는 것입니다.

## 나쁜 코드 vs 좋은 코드 예시

이제 간단한 **예시 코드**를 통해 클린 코드 원칙이 어떻게 코드 품질을 바꾸는지 살펴보겠습니다. 아래에는 같은 기능을 수행하지만 **차이가 큰 두 가지 코드**가 있습니다. 첫 번째는 클린 코드 원칙이 적용되지 않은 "나쁜 코드" 예시이고, 두 번째는 이를 개선한 "좋은 코드" 예시입니다.

### 나쁜 코드 예시

```python
# 나쁜 코드 예시: 여러 가지 일을 하고 중복이 많은 함수
def analyze_numbers(numbers):
    pos_count = 0
    neg_count = 0
    # 양수/음수 개수 세기 (중첩 if로 0 처리)
    for n in numbers:
        if n >= 0:
            if n == 0:
                pass  # 0은 양수도 음수도 아니므로 무시
            else:
                pos_count += 1
        if n < 0:
            neg_count += 1
    print("Positive count:", pos_count)
    print("Negative count:", neg_count)
    # 짝수 제곱수 구하기 (별도 리스트 사용)
    evens = []
    for n in numbers:
        if n % 2 == 0:
            evens.append(n * n)
    print("Even squares are:")
    for e in evens:
        print(e)
    # 짝수 제곱수 합계 구하기 (중복 루프)
    total = 0
    for e in evens:
        total = total + e
    print("Total is", total)

# 예시 입력
nums = [-5, -3, -1, 0, 1, 2, 3, 4]
analyze_numbers(nums)
```

위 코드는 한 함수 `analyze_numbers` 안에서 **양수/음수 개수 세기**, **짝수인 수의 제곱 목록 만들기**, **합계 계산**, **결과 출력**까지 **네 가지 일을 한꺼번에** 하고 있습니다. 중간중간 중첩된 `if`문과 세 번의 `for` 루프가 보이네요. 결과를 확인하면 다음과 같습니다.

```plaintext
Positive count: 4  
Negative count: 3  
Even squares are:  
0  
4  
16  
Total is 20  
```

이 코드의 문제점을 정리하면:

- 함수 하나에 너무 많은 일을 처리하고 있어 **단일 책임 원칙**에 어긋납니다. (데이터 분류, 변환, 출력 등)
- 같은 리스트를 두 번(`numbers`에 대한 두 개의 `for` 루프) 순회하고, 짝수 리스트 `evens`도 두 번 (`print`와 합계 계산) 순회하여 **중복**이 존재합니다.
- 양수/음수 계산을 위한 `if n >= 0` 내부에 또 `if n == 0`을 넣는 등 **불필요하게 중첩된 조건문**이 있어 코드를 읽기 어렵게 만듭니다.
- 모든 로직이 함수 내부에 하드코딩 되어 있고 출력까지 담당해서, 함수의 **부작용**(콘솔 출력)이 있습니다. 이렇게 하면 나중에 이 함수를 재사용하여 값을 리턴받거나 다른 형태로 활용하기 어렵습니다.

### 좋은 코드 예시

이제 위 코드를 클린 코드 원칙에 따라 리팩토링한 예시를 보겠습니다. 가능한 한 위와 동일한 동작을 유지하면서, 코드를 개선해 보았습니다. 

```python
# 좋은 코드 예시: 기능별로 함수 분리, 중복 제거, 가독성 향상
def count_signs(numbers):
    """리스트에서 양수와 음수의 개수를 반환"""
    pos_count = 0
    neg_count = 0
    for n in numbers:
        if n > 0:
            pos_count += 1
        elif n < 0:
            neg_count += 1
    return pos_count, neg_count

def get_even_squares(numbers):
    """리스트에서 짝수들의 제곱을 모아 리스트로 반환"""
    return [n * n for n in numbers if n % 2 == 0]

# 개선된 분석 함수 (핵심 로직을 호출하고 출력만 담당)
def analyze_numbers_refactored(numbers):
    pos_count, neg_count = count_signs(numbers)
    evens = get_even_squares(numbers)
    total = sum(evens)
    # 결과 출력 (부작용은 이 부분에만 한정)
    print("Positive count:", pos_count)
    print("Negative count:", neg_count)
    print("Even squares are:")
    for e in evens:
        print(e)
    print("Total is", total)

# 동일한 입력에 대해 새 함수 사용
analyze_numbers_refactored(nums)
```

위 코드는 이전의 나쁜 코드를 단계별로 개선하여 얻은 결과입니다. 출력 결과는 이전과 동일합니다.

```plaintext
Positive count: 4  
Negative count: 3  
Even squares are:  
0  
4  
16  
Total is 20  
```

개선된 코드의 특징은 다음과 같습니다.

- 기능별로 `count_signs`와 `get_even_squares` 함수를 분리하여 **각 함수가 한 가지 일만** 수행하도록 했습니다. 덕분에 `analyze_numbers_refactored`는 주요 로직을 호출하고 결과를 출력하는 역할만 담당합니다. 이러한 분리는 코드의 **응집도**를 높이고 재사용성을 높여줍니다.
- `get_even_squares` 함수에서는 **리스트 컴프리헨션**을 사용하여 짝수의 제곱 목록을 한 줄에 생성했습니다. 불필요한 루프와 `append` 호출을 줄여 코드가 간결해졌습니다.
- 합계 계산에 `sum()` **내장 함수를 활용**하여 명시적으로 루프를 돌며 더하지 않아도 되도록 바꾸었습니다. 이로써 짝수 리스트를 순회하는 중복된 코드가 제거되었습니다.
- 양수/음수 계산 부분의 조건문을 `if-elif-else` 구조로 단순화하여 **들여쓰기 수준을 줄이고** 논리가 한 눈에 들어오도록 했습니다. `if n > 0 / elif n < 0 / else`로 분기하여 0 처리도 별도의 중첩 없이 구현되었습니다.
- 주요 로직을 분리함으로써 출력(`print`)이라는 부작용이 핵심 계산에서 분리되었습니다. 이제 계산 함수들은 출력이나 외부 영향 없이 **결과를 반환**만 하므로, 필요하다면 출력 대신 다른 형태로 결과를 활용할 수도 있습니다.

요약하면, 좋은 코드 예시는 **클린 코드의 원칙**들 – 의미 있는 이름, 작은 함수, 중복 제거, 단순한 제어 구조, 최소 부작용 – 을 적용하여 읽기 쉽고 변경하기 쉽게 개선되었습니다. 반면, 기능은 나쁜 코드와 동일하게 동작함을 확인할 수 있습니다 (결과가 동일함). 실제로 리팩토링에서는 이렇게 **결과는 바꾸지 않고 코드만 개선**하는 것이 목표입니다.

## GitHub Copilot을 활용한 클린 코드 실습

이제 **GitHub Copilot**이라는 AI 코딩 도구를 활용하여 클린 코드를 작성하고 리팩토링하는 몇 가지 방법을 실습해보겠습니다. Copilot은 코드를 자동 완성하고 리팩토링을 제안해주는 도구로, 우리가 작성하는 주석이나 코드 컨텍스트를 바탕으로 유용한 코드 조각을 추천해줍니다. 아래 실습에서는 **의미 있는 이름으로 함수/변수를 작성할 때 Copilot의 자동 완성**, **주석/독스트링을 활용한 함수 코드 생성**, **Copilot Chat으로 복잡한 분기문 리팩토링** 등을 다뤄보겠습니다.

### 의미 있는 이름으로 자동 완성 받기

클린 코드의 첫 걸음은 **좋은 이름 짓기**입니다. Copilot은 개발자가 작성 중인 이름을 실시간으로 분석하여 이어질 코드를 추측하는데, 이때 **의미 있는 함수명이나 변수명**을 사용하면 더욱 정확하고 유용한 제안을 받을 수 있습니다. 예를 들어, 함수를 작성할 때 이름을 구체적으로 지어보겠습니다:

```python
# Copilot 제안을 활용한 함수 예제
def calculate_average_age(person_list):
    total_age = 0
    for person in person_list:
        total_age += person.age
    return total_age / len(person_list)
```

위 코드를 작성할 때 함수를 `calculate_average_age`처럼 **의도와 대상이 분명한 이름**으로 쓰기 시작하면, Copilot은 함수 내부에 어떤 동작이 필요할지 예측하여 자동 완성해줄 수 있습니다. `person_list`라는 인자 이름도 사람들의 목록임을 드러내므로, 루프에서 `for person in person_list:`와 같이 사람 각각을 `person`으로 처리하는 코드를 Copilot이 제안할 수 있습니다. 만약 이름을 `func1`, `x`처럼 지었다면 Copilot도 맥락을 알기 어려워 엉뚱한 제안을 할 확률이 높습니다. **결론:** 의미 있는 이름을 사용하면 Copilot도 그 의도를 파악해 보다 깨끗한 코드를 작성하도록 도와줍니다.

### 주석과 독스트링으로 함수 자동 완성하기

Copilot은 **주석**이나 **독스트링**(docstring)에 작성된 설명을 기반으로 코드를 생성하는데도 뛰어난 능력을 보여줍니다. 이는 곧 개발자가 **함수의 의도를 먼저 말로 정의**하고, 구현은 Copilot의 제안을 받아볼 수 있다는 뜻입니다. 이러한 접근은 클린 코드 작성에 유용한데, 먼저 원하는 동작을 명확히 서술하게 되어 잘못된 방향으로 코딩하는 것을 방지하고, Copilot의 제안을 통해 빠르게 기초 코드를 얻은 후 수정할 수 있기 때문입니다.

예를 들어, 팩토리얼(factorial) 함수를 작성해보겠습니다. 우선 함수의 독스트링에 무엇을 하는 함수인지 적습니다.

```python
def factorial(n):
    """주어진 양의 정수 n의 팩토리얼 값을 계산하여 반환한다."""
    # Copilot이 이 아래에 자동으로 코드를 완성해줄 것입니다.
```

독스트링을 작성한 뒤 잠시 기다리거나 Copilot 단축키를 누르면, Copilot이 이 설명에 맞는 코드를 제안합니다. 예상되는 자동완성 코드는 재귀적으로 팩토리얼을 구현한 아래와 같을 것입니다.

```python
def factorial(n):
    """주어진 양의 정수 n의 팩토리얼 값을 계산하여 반환한다."""
    if n <= 1:
        return 1
    else:
        return n * factorial(n-1)
```

이처럼 **자연어로 작성된 함수 설명**만으로도 Copilot은 함수 구현을 제시할 수 있습니다. 우리는 Copilot의 결과를 검토하여 논리의 오류는 없는지, 예외 상황은 처리되는지 확인하고 필요하면 수정하면 됩니다. 주석을 활용한 자동 완성도 비슷한 방식으로 이루어집니다. 예를 들어 함수 내부에 `# TODO: 리스트에 있는 음수 숫자 개수를 센다`라고 주석을 달면, 그 아래에 곧바로 `count_negatives = sum(1 for x in numbers if x < 0)`와 같은 코드를 Copilot이 넣어줄 수도 있습니다. 정리하면, **명확한 주석과 설명**은 Copilot에게 의도를 전달하여 보다 깨끗한 코드를 빨리 작성하게 해주는 유용한 수단입니다.

### Copilot Chat으로 복잡한 if-else 문 리팩토링하기

Copilot은 단순한 코드 자동 완성 뿐 아니라 **대화형 Copilot Chat**을 통해 코드 리팩토링을 도와주기도 합니다. Copilot Chat에 현재 코드를 보여주고 *"이 코드를 리팩토링해줘"* 또는 *"복잡한 if-else문을 더 간결하게 바꿔줘"* 같은 요청을 하면, 개선된 코드를 제안해줍니다. 특히 **복잡한 분기문**을 가진 코드에서는 Copilot의 도움을 받아 더 깨끗한 형태로 고치기 쉽습니다.

예를 들어, 아래와 같이 국가 코드를 국가 이름으로 변환하는 함수가 있다고 가정해보겠습니다. 여러 개의 `elif`로 나열되어 있어 수정이나 추가 시 비효율적인 코드입니다.

```python
# Copilot Chat 사용 전: 복잡한 if-elif 분기
def get_country_name(code):
    if code == "KR":
        return "Korea"
    elif code == "US":
        return "United States"
    elif code == "JP":
        return "Japan"
    elif code == "CN":
        return "China"
    else:
        return "Unknown"
```

이 코드를 Copilot Chat에 넣고 *"더 나은 방식으로 리팩토링해줘"* 라고 요청하면, Copilot은 아래와 같은 개선안을 제시할 수 있습니다.

```python
# Copilot Chat 제안 후: 딕셔너리 기반 리팩토링
def get_country_name(code):
    country_map = {
        "KR": "Korea",
        "US": "United States",
        "JP": "Japan",
        "CN": "China"
    }
    return country_map.get(code, "Unknown")
```

이 리팩토링된 코드를 보면, 여러 `elif`를 일일이 쓰는 대신 **딕셔너리**를 활용하여 코드 구조가 훨씬 단순해졌습니다. 새로운 국가 코드를 추가할 때도 딕셔너리에만 값을 넣으면 되므로 유지보수가 쉬워집니다. Copilot Chat은 이처럼 **더 파이썬스러운(Pythonic)** 코드나 알고리즘을 제안해줄 때가 많으며, 우리 대신 장황한 분기문을 정리해주기도 합니다.

Copilot Chat의 제안을 받을 때 중요한 것은 **제안된 코드의 동작이 원래 코드와 동일한지 검증**하는 것입니다. 위 예시의 경우 결과적으로 동작은 같지만, 개발자가 직접 `country_map` 딕셔너리를 검토하여 오타나 누락된 키가 없는지 확인해야 합니다. 복잡한 분기문을 자동으로 바꾸어줄 때 Copilot이 간혹 원래 코드와 살짝 다른 동작을 만들 수도 있으므로 (예를 들어 경계 조건이나 일부 케이스를 빠뜨릴 수 있음), 반드시 **테스트를 통해 검증**하는 단계가 필요합니다.

## 리팩토링의 개념과 필요성

**리팩토링**(Refactoring)이란 **겉으로 보이는 프로그램의 기능은 그대로 둔 채, 코드의 내부 구조를 개선하는 과정**을 말합니다. 중요한 점은 리팩토링 전후에 **동일한 기능을 수행**해야 한다는 것입니다. 위에서 좋은 코드 예시로 개선한 것도 결과 출력은 같았지만 코드 구조만 바뀐 것을 볼 수 있습니다. 리팩토링의 대표적인 목표는 **가독성 향상과 유지보수성 증대**입니다. 새로운 기능을 추가하거나 버그를 직접 수정하는 것은 리팩토링에 포함되지 않으며, 오로지 코드 품질 개선에 집중합니다. 리팩토링을 통해 얻을 수 있는 효과는 다음과 같습니다:

- **코드 이해도 상승**: 깨끗하게 정리된 코드는 개발자 누구라도 이해하기 쉬워집니다. 그러면 수정이나 기능 추가를 할 때 실수를 줄일 수 있고, 협업 시 소통 비용도 낮아집니다.
- **버그 감소**: 중복 제거 등 리팩토링은 잠재적인 버그 소지를 없애줍니다. 같은 로직을 한 곳에서 관리하면 실수로 한 군데만 고치는 일이 줄어들고, 코드 구조가 명확해지면 논리 오류를 발견하기도 쉬워집니다.
- **개선의 선순환**: 리팩토링된 코드는 **변경에 유연**해집니다. 새로운 요구사항이 생겨도 깔끔한 구조 위에 구현하면 되므로 개발 속도가 붙고, 이렇게 개선된 부분은 다시 유지보수하기 쉬운 코드가 되어 긍정적인 순환이 이루어집니다.

결국 리팩토링은 **코드 품질을 지속적으로 높이는 과정**이며, 이를 통해 개발 생산성과 소프트웨어의 수명을 늘릴 수 있습니다. 자잘한 리팩토링은 코딩 중에도 수시로 이루어질 수 있고, 때로는 기능 구현을 마친 후 별도의 시간을 들여 리팩토링하기도 합니다. 중요하게 기억할 것은: “**리팩토링 전과 후의 기능은 동일해야 한다**”는 것입니다. 이를 확인하기 위해 리팩토링 전후에 테스트를 해보는 습관도 필요합니다.

## 파이썬 코드 리팩토링 실습 예시

이번에는 간단한 파이썬 코드를 **단계별로 리팩토링**해보는 실습을 진행합니다. 먼저 리팩토링을 할 예시 코드를 준비합니다. 이 코드는 일부러 몇 가지 개선 가능성을 지니도록 작성되었습니다 (일부러 나쁘게 작성되었다고 볼 수 있습니다).

```python
# 리팩토링 실습용 초기 코드
def process_scores(scores):
    """점수 리스트를 받아, 통과 여부 판단 및 통계 출력"""
    # 1. 통과한 학생 수 세기 (점수 60 이상을 통과로 간주)
    pass_count = 0
    for s in scores:
        if s >= 60:
            pass_count += 1
    fail_count = len(scores) - pass_count  # 실패한 학생 수
    
    # 2. 최고점과 최저점 찾기
    max_score = scores[0]
    min_score = scores[0]
    for s in scores:
        if s > max_score:
            max_score = s
        if s < min_score:
            min_score = s
    
    # 3. 평균 계산 (소수 첫째자리까지)
    total = 0
    for s in scores:
        total += s
    average = total / len(scores)
    
    # 4. 결과 출력
    print(f"총 학생 수: {len(scores)}")
    print(f"통과한 학생 수: {pass_count}")
    print(f"탈락한 학생 수: {fail_count}")
    print(f"최고 점수: {max_score}")
    print(f"최저 점수: {min_score}")
    print(f"평균 점수: {average:.1f}")
```

`process_scores` 함수는 학생들의 점수 리스트를 받아 다음을 수행합니다:

1. 통과한 학생 수(pass_count)와 탈락한 학생 수(fail_count)를 계산하여 출력  
2. 최고 점수(max_score)와 최저 점수(min_score)를 찾아 출력  
3. 평균 점수(average)를 계산하여 출력  

위 함수는 동작은 하지만 개선 여지가 많이 보입니다. 우리가 적용해볼 리팩토링 아이디어는 다음과 같습니다:

- **중복되는 코드 줄이기**: `scores` 리스트를 세 번이나 반복(`for`)문으로 순회하고 있습니다. 가능하면 한 번의 순회로 필요한 값을 모두 계산하거나, 파이썬 내장 함수/라이브러리를 활용하여 중복 순회를 줄일 수 있습니다.
- **조건문 간소화**: 현재는 통과 여부를 계산할 때 일일이 `if`문을 사용했지만, 파이썬의 **리스트 컴프리헨션**이나 **sum 함수**를 활용하면 더 간결하게 표현할 수 있습니다. 
- **함수 분리**: 한 함수에서 너무 많은 일을 처리하면 이해하기 어려우므로, 필요한 경우 로직을 적절히 **함수로 분리**해볼 수 있습니다. 예를 들면 통계량 계산과 출력 기능을 분리할 수 있습니다.
- **파이썬스러운 표현 사용**: 평균 계산 등에서 굳이 직접 합계를 구하지 않고 `sum()`을 쓰는 등, 파이썬이 제공하는 간결한 표현으로 개선할 수 있습니다. 또한 리스트를 순회하며 최대/최소를 찾는 대신 `max()`/`min()` 함수를 사용할 수도 있습니다.

### 1단계: 중복되는 코드 줄이기 (반복 순회 제거)

먼저 **중복된 반복문**을 제거해 보겠습니다. 위 코드에서는 `scores`를 세 차례(`통과 계산`, `최고/최저`, `합계 계산`) 순회합니다. 한 번만 순회하면서 필요한 값을 모두 계산하도록 바꿔 보겠습니다. 또한 각 통계값을 한 곳에 모아 **리턴**하도록 해보겠습니다 (출력은 일단 제외하고 계산만). 

```python
def process_scores_refactor1(scores):
    """점수 리스트의 통과자 수, 실패자 수, 최고점, 최저점, 평균을 계산하여 반환"""
    pass_count = 0
    fail_count = 0
    total = 0
    max_score = float('-inf')  # 음의 무한대로 초기화
    min_score = float('inf')   # 양의 무한대로 초기화
    for s in scores:
        # 통과/탈락 계산
        if s >= 60:
            pass_count += 1
        else:
            fail_count += 1
        # 최고/최저 갱신
        if s > max_score:
            max_score = s
        if s < min_score:
            min_score = s
        # 합계 누적
        total += s
    average = total / len(scores)
    return pass_count, fail_count, max_score, min_score, average

# 새 리팩토링 함수 테스트
result = process_scores_refactor1([30, 90, 55, 77, 89])
print(result)  # (통과자수, 탈락자수, 최고점, 최저점, 평균)
```

```
(3, 2, 90, 30, 68.2)
```

**변경점:** 하나의 `for` 루프 안에서 `pass_count`, `fail_count`, `max_score`, `min_score`, `total`을 모두 계산했습니다. 이렇게 하면 리스트를 한 번만 읽으면서 필요한 통계를 모두 얻을 수 있습니다. 중복 루프가 제거되어 **효율성**이 올라가고, 관련된 계산이 한 곳에 모여 있어 **코드의 응집도**도 높아집니다. 

한 가지 고려사항은 이렇게 한 번에 계산하면 **함수가 조금 길어질 수 있다**는 점입니다. 이는 경우에 따라 트레이드오프입니다. 만약 이런 계산이 매우 복잡해진다면, 두 번 순회하더라도 함수들을 분리하는 편이 나을 수도 있습니다. 여기서는 복잡도가 높지 않으므로 한 루프에 통합했습니다.

### 2단계: 조건문 간소화 및 파이썬 내장 함수 활용

1단계에서 통과자 수를 계산할 때 우리는 수동으로 `if s >= 60: pass_count += 1`를 했습니다. 파이썬에서는 이와 동일한 일을 한 줄로 할 수 있습니다. 바로 **리스트 컴프리헨션**과 `sum()`을 활용하는 방법입니다. `[1 for s in scores if s >= 60]` 는 점수 리스트에서 60 이상인 항목들에 대해 1을 내놓는 리스트를 만들고, `sum()`을 취하면 곧 60 이상인 개수를 구하게 됩니다. 실패자 수는 전체 길이에서 통과자 수를 빼면 되겠죠. 또한 최대값, 최소값, 합계도 파이썬 내장 함수를 써서 구할 수 있습니다 (`max(scores)`, `min(scores)`, `sum(scores)`). 이들을 활용해 코드를 대폭 줄여보겠습니다.

```python
def process_scores_refactor2(scores):
    """점수 리스트의 통계량을 계산하여 튜플로 반환 (내장 함수 활용)"""
    pass_count = sum(1 for s in scores if s >= 60)
    fail_count = len(scores) - pass_count
    max_score = max(scores)
    min_score = min(scores)
    average = sum(scores) / len(scores)
    return pass_count, fail_count, max_score, min_score, average

# 새 리팩토링 함수 테스트
result = process_scores_refactor2([30, 90, 55, 77, 89])
print(result)
```

```
(3, 2, 90, 30, 68.2)
```

이렇게 함으로써 `process_scores_refactor2` 함수는 **6줄 만에** 동일한 결과를 산출합니다. 주요 개선 사항:

- `sum(1 for s in scores if s >= 60)`를 통해 통과자 수 계산을 **루프 없이 간결하게 표현**했습니다. (`sum()`과 **제너레이터 표현식**을 사용)
- `max()`, `min()`, `sum()` 등 **파이썬 내장 함수를 활용**하여 가독성을 높였습니다. 이러한 내장 함수들은 C로 구현되어 Python 루프로 직접 계산하는 것보다 효율이 높을 수도 있고, 무엇보다 의도를 명확히 전달합니다 (“최대값을 구한다”는 것을 `max(scores)`만으로 알 수 있음).
- 조건문 중첩이 필요없어졌고, 코드 라인이 크게 줄어 전체 구조를 한눈에 파악할 수 있습니다.

이 단계에서는 **클린 코드 = 무조건 코드 줄 수 감소**는 아님을 짚고 넘어가야 합니다. 때로는 가독성을 위해 한 줄을 여러 줄로 나누기도 하고, **명확함**이 더 중요하면 장황하더라도 직관적인 코드가 나을 수 있습니다. 그러나 위 예시는 파이썬답게 표현함으로써 더 읽기 좋은 코드가 된 경우라서, 코드가 줄어든 것이 곧 가독성 향상으로 이어졌습니다. (코드 골프를 하라는 것이 아닙니다!)

### 3단계: 함수 분리 및 구조화

이제 계산한 통계 값을 **출력하는 부분**을 분리해보겠습니다. 현재 `process_scores_refactor2`는 통계 계산만 하고 결과를 반환하도록 했습니다. 이를 활용하여 출력까지 담당하는 함수를 따로 만들면 역할이 명확히 나누어집니다. 예를 들어 `print_score_stats(stats)` 함수를 만들어, 튜플로 받은 통계치를 형식에 맞게 출력하게 할 수 있습니다. 또는 `process_scores` 함수 자체에 인자를 추가하여 출력 여부를 조절할 수도 있겠지만, 여기서는 단일 책임을 강조하기 위해 아예 출력을 별도 함수로 분리하겠습니다.

```python
def print_score_stats(stats):
    """통계 튜플을 받아 사람-readable하게 출력"""
    pass_count, fail_count, max_score, min_score, average = stats
    total_students = pass_count + fail_count
    print(f"총 학생 수: {total_students}")
    print(f"통과한 학생 수: {pass_count}")
    print(f"탈락한 학생 수: {fail_count}")
    print(f"최고 점수: {max_score}")
    print(f"최저 점수: {min_score}")
    print(f"평균 점수: {average:.1f}")

# 사용 예시
stats = process_scores_refactor2([30, 90, 55, 77, 89])
print_score_stats(stats)
```

```
총 학생 수: 5  
통과한 학생 수: 3  
탈락한 학생 수: 2  
최고 점수: 90  
최저 점수: 30  
평균 점수: 68.2  
```

이러한 **함수 분리**를 통해 계산 로직과 출력 로직이 완전히 나뉘었습니다. 이제 `process_scores_refactor2` 함수는 계산 결과를 리턴하기만 하기 때문에 **부작용이 없는 순수 함수**처럼 동작합니다. 나중에 이 함수를 다른 모듈에서 불러와 사용하더라도 print가 발생하지 않으니 안심하고 재사용할 수 있죠. 반면 `print_score_stats`는 오로지 출력만 담당하므로 역할이 선명해졌습니다. 이처럼 **관심사의 분리**를 하면 코드가 약간 길어질 수는 있지만, 각각의 함수가 매우 단순해지기 때문에 전체적인 이해도는 올라갑니다.

Copilot도 이러한 리팩토링에 도움을 줄 수 있습니다. 예를 들어 우리가 `print_score_stats` 함수를 만들고 통계 튜플을 언패킹하려 할 때, Copilot이 자동으로 `pass_count, fail_count, max_score, min_score, average = stats` 코드를 제안해줄 수 있습니다. 또한 docstring을 쓰면 그 내용을 출력하는 `print`문도 일부 완성해줄 수도 있습니다. Copilot의 제안을 받아 코드를 작성할 때도 항상 **함수의 단일 책임**을 염두에 두면, 코드를 더 구조적으로 완성할 수 있습니다.

### 4단계: Copilot의 리팩토링 제안 검토 및 마무리

마지막으로, 실제로 Copilot에게 이 코드를 리팩토링하도록 요청했다고 가정해보겠습니다. Copilot Chat에 초기 코드를 주고 "리팩토링 개선해줘"라고 하면 아마도 위에서 우리가 만든 최종 코드와 매우 유사한 형태로 개선안을 내놓을 가능성이 큽니다. 예를 들어 Copilot이 다음과 같은 코드를 제안했다고 해보죠.

```python
def process_scores_refactored(scores):
    pass_count = sum(1 for s in scores if s >= 60)
    fail_count = len(scores) - pass_count
    max_score = max(scores)
    min_score = min(scores)
    average = sum(scores) / len(scores)
    print(f"총 학생 수: {len(scores)}")
    print(f"통과한 학생 수: {pass_count}")
    print(f"탈락한 학생 수: {fail_count}")
    print(f"최고 점수: {max_score}")
    print(f"최저 점수: {min_score}")
    print(f"평균 점수: {average:.1f}")
```

Copilot의 제안은 계산과 출력 모두 한 함수에 넣은 형태일 수 있습니다. 이는 우리가 2단계까지 개선한 코드와 유사하지만, 출력 부분을 동일 함수에 포함하고 있네요. 이 상태도 원래 코드보다는 훨씬 나아졌지만, 우리는 한 걸음 더 나아가 출력 분리를 해봤었습니다. Copilot이 항상 최상의 구조를 제안하는 것은 아니므로, **개발자의 판단으로 한 번 더 구조를 개선할 수 있습니다**. 

또한 위 코드는 함수명이 `process_scores_refactored`로 자동 붙었는데, 실제로는 같은 이름으로 덮어써야 하겠죠. 이런 사소한 부분도 개발자가 마무리해야 합니다. 중요한 것은 Copilot이 제안한 후 **테스트를 통해 기능이 동일한지 검증**하는 것입니다. 제안된 코드와 원래 코드가 동일한 출력이나 결과를 내는지 확인해야 하며, Copilot이 간혹 간과한 엣지 케이스는 없는지 살펴봐야 합니다. 

우리의 경우 간단히 눈으로 로직을 비교하거나, 몇 가지 입력에 대해 실행해보면서 결과가 같은지 확인하면 됩니다. 이렇게 함으로써 Copilot의 리팩토링 제안을 **신뢰하지만 검증하면서** 활용할 수 있습니다. Copilot은 빠르게 코드를 개선하는 아이디어를 주지만, **책임은 여전히 개발자**에게 있기 때문입니다.

## 실습 요약 및 Copilot 활용 시 주의점

마지막으로 이번 강의안의 내용을 정리하고, GitHub Copilot을 사용할 때의 **주의할 점**을 간략히 언급합니다.

**정리 – 오늘의 핵심**: 클린 코드는 **읽기 쉽고 유지보수하기 좋은 코드**이며, 이를 위해 의미 있는 이름 짓기, 함수당 하나의 역할, 중복 제거, 단순한 구조, 최소한의 부작용 같은 원칙들을 적용해야 합니다. 예시를 통해 나쁜 코드를 좋은 코드로 리팩토링하면서 이러한 원칙들이 실제 코드에 어떻게 나타나는지 살펴보았습니다. 또한 **리팩토링**은 기능은 바꾸지 않고 코드 구조만 개선하는 것이며, 꾸준한 리팩토링을 통해 코드 품질을 높일 수 있음을 배웠습니다. 

**GitHub Copilot 활용**: Copilot은 코드 작성과 리팩토링을 도와주는 훌륭한 도구입니다. 우리는 Copilot의 자동 완성으로 빠르게 함수를 구현하고, Copilot Chat을 통해 복잡한 코드를 단순화하는 예제를 실습했습니다. Copilot을 사용할 때 얻을 수 있는 이점은 **생산성 향상**과 **아이디어 제안**입니다. 반복적인 코드를 자동으로 완성해주거나, 더 나은 구현 방식을 추천해주므로 개발 속도가 빨라지고 다양한 솔루션을 탐색할 수 있습니다.

**주의할 점**: Copilot의 제안이 항상 100% 최선은 아니라는 점을 명심해야 합니다. Copilot은 훈련된 데이터를 기반으로 추측하여 코드를 작성하기 때문에, **상황에 따라 부적절한 코드나 비효율적인 코드를 제안할 수도 있습니다**. 특히, Copilot이 만들어준 코드가 문법적으로 맞고 얼핏 동작할 것 같아 보여도, 우리는 반드시 **그 코드를 리뷰하고 테스트**해야 합니다. 예를 들어 Copilot이 제안한 코드에 사소한 버그가 있을 수 있고, 변수명 등 스타일이 우리의 코드베이스와 맞지 않을 수도 있습니다. 또한 보안이나 성능 측면에서 미흡한 부분이 있을 수 있으므로, 이러한 것은 개발자의 판단으로 보완해야 합니다. 

Copilot을 쓸 때 **맹신하지 말고 참고용으로 활용**하는 태도가 중요합니다. Copilot이 제시한 해결책을 그대로 쓰기보다는, “왜 이렇게 제안했을까? 더 나은 방법은 없을까?”를 한 번 생각해보고, 필요하면 직접 개선하세요. 결국 클린 코드의 최종 책임은 도구가 아닌 **개발자 본인에게 있음**을 기억해야 합니다.

이번 수업을 통해 클린 코드의 개념과 원칙을 이해하고, 간단한 파이썬 코드의 리팩토링 과정을 경험해봤습니다. 실무에서 코딩을 할 때도 수시로 코드 품질을 돌아보고, 필요하면 과감하게 리팩토링하면서 **보다 깨끗한 코드**를 추구하시길 바랍니다. GitHub Copilot과 같은 도구도 현명하게 활용하면 여러분의 든든한 페어 프로그래머가 되어줄 것입니다. 즐거운 코딩 되세요!